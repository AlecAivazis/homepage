---
title: Building an Ethereum Dapp With GraphQL
subtitle: Using GraphQL as a query language for your smart contracts
path: '/blog/ethereum-and-graphql'
date: '2019-03-01'
---

Even the simplest decentralized applications involve information that is spread
across many different sources. Querying this information for a user interface
can become unwieldy as we have to hop across our collection of contracts to gather
the particular data that we need. On top of that, unless we are very careful, our
components can easily become intimately tied with the architecture details of our
application. In this blog post, I will show you how to use GraphQL as a powerful
abstraction over your contracts that ultimately simplifies the construction and
maintainence of your dapp's user interface.

_This post is not meant to be an introduction to ethereum or graphql.
That being said, I will try to explain enough that you shouldn't need too much
familiarity with either to follow along. For a good introduction to the basics of
decentralized applications, I recommend
[this article](https://medium.com/@mvmurthy/ethereum-for-web-developers-890be23d1d0c).
For an introduction to GraphQL I recommend [starting here](https://graphql.org/learn/)._

=-=

In this post we will build an auction platform like [eBay](https://ebay.com) where users can
post items for sale that can be bid on by other users. For now, we will only show how one
would fire a single query since the rest would be more of the same. If you would like to see a more fleshed out example in the form of a multi-post series, please let me know on twitter or
[this blog's repo](https://github.com/AlecAivazis/homepage).

The code for this post lives [on github](https://github.com/AlecAivazis/ethereum-graphql-demo).
The platform is made up of two different contracts. One is called `AuctionHub` which maintains
a list of addresses that point to instances of another contract called `Auction`. That second
contract only has a single public field: the name of the item for sale.

# Deploying The Contracts

Let's deploy some contracts to a test evironment so we have something to query. Clone the demo
project and install the project dependencies. A small warning: this might take a bit.

```bash
git clone git@github.com:AlecAivazis/ethereum-graphql-demo.git \
    && cd ethereum-graphql-demo \
    && npm i
```

Once it's done, start a local ethereum node we can test against:

```bash
npm run testnet
```

Notice the list of accounts under `Available Accounts`. We'll need one of them later. In
another terminal, compile the contracts:

```bash
npm run build:contracts
```

You should now have two files for each contract. The `*.bin` files are the compiled version
of each contract and the `*.abi` are a json files that describe the contents of the contract
(attributes, methods, etc.).

The demo project comes with a script that will bootstrap a few constracts and print the
address of the hub. Before you can run it, you have to update the address that you want
to you when creating our test contracts [here](). Once that is updated, you can create
the demo contracts with:

```bash
npm run init
```

With our contracts deployed, we are now ready to start querying them with GraphQL.

# Ethereum and GraphQL

If you have heard of GraphQL before, it's very likely that it was as a specification for a
server's API. In the decentralized world, there is no central server like there
is in traditional architectures. That does not mean, however, that we cannot take advantage of
all of the amazing tooling that the GraphQL community has produced.

By defining a schema that exists only in our client, we can use GraphQL as an abstraction layer over
our collection of contracts. This allows us to query the current state of our platform as if it was
a traditional server and resolve queries against the blockchain.

# Building Our Client

The repo already contains a very basic UI that that we can just use without worrying too much about
how it works. Just know that if you change the queries that your components are firing, or the graphql
schema, you have to re-run the compiler with `npm run relay` for the changes to take effect.

## Defining the Schema

The first step to building our client-side graphql layer is the same as in the traditional world: define
a schema to represent our domain. This schema encodes the internal API between our UI
and contracts. This schema and its resolvers can even act as the handoff between the teams responsible
for blockchain and UI development (if that separation makes sense for you).

Let's start by adding a file named `schema.js` under the `src/` directory with this content:

```javascript
import { makeExecutableSchema } from 'graphql-tools'

const schema = `
    type Auction {
        id: ID!
        itemName: String!
    }

    type Query {
        allAuctions: [Auction!]!
    }
`

export default makeExecutableSchema({
    typeDefs: schema,
})
```

If you have experience with the `graphql-tools` package then this should look familiar. What we've done
here is define a GraphQL schema that let's us query for all of the auctions in our system. You'll notice that
there is no mention of `AuctionHub` anywhere. Its existence does not need to leak
into the UI's model of the platform's state. We're already seeing some benefits to this setup! Our UI
team doesn't have to understand how to find each auction. As we'll see in the bit, they just have
to be able to fire a query like `{ allAuctions { itemName } }`.

At the moment, keeping this in sync with the public attributes of our contract is a manual task.
It is possible to automate this for a smoother developer experience if you or your company finds
themselves doing this a lot.

## Specifying Resolvers

On it's own, a schema is not enough to resolve queries. We also need to tell the runtime
how to resolve the requested fields. This is done by defining an object whose keys are the type name and
whose values are another object with resolvers for the fields:

```javascript
import { makeExecutableSchema } from 'graphql-tools'
import { HubABI, AuctionABI, web3 } from '../contracts'

const schema = ...

const resolvers = {
    Auction: {
        // for now just use the address as the id
        id: auction => auction.options.address,
        // auction is an instance of the Auction contract wrapper
        itemName: auction => auction.methods.itemName().call(),
    },
    Query: {
        allAuctions: () => {
            // create a reference to the hub contract we created earlier
            const hub = new web3.eth.Contract(HubABI, 'hub address from earlier')

            // build the list of auctions
            const auctions = []
            for (let i = 0; i < await hub.methods.auctionCount().call(); i++) {
                auctions.push(
                    new web3.eth.Contract(
                        AuctionABI,
                        await hub.methods.auctions(i).call()
                    )
                )
            }

            return auctions
        }
    },
}

export default makeExecutableSchema({
    typeDefs: schema,
    resolvers,
})
```

As you can see, we've told the runtime that resolving the `itemName` field on the
`Auction` object type requires invoking `itemName` method on the instance of the auction contract.
This returns a promise with the the value of a
["constant" method](https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#methods-mymethod-call) which
will give us the string we want.
Similarly, we resolve the list of all available auctions by looking at the auction hub
we created earlier and returning an instance of the auction constract for each address stored in the hub.

It's worth highlighting again that by doing this, we have completely abstracted away the existence of
the hub from the user interface. If we do in fact have separate teams working on the UI and
the blockchain infrastructure, this schema acts as a convinient touch point between the two teams.
If the blockchain team needs to rely on some centralized source as well, this schema can be easily
[stitched](https://www.apollographql.com/docs/graphql-tools/schema-stitching.html) with schemas from
remote APIs for powerful hybrid applications without complicating the user interface with those details.

## Querying Our Schema

With our schema in place, we are now ready to start wiring up the user interface and our contracts.
In relay, the central specification for how a query is resolved lives in an object known as the
[Environment](https://facebook.github.io/relay/docs/en/relay-environment.html). This is analogous
to a mixture of Apollo's `Link` and `Client` as described
[here](https://www.apollographql.com/docs/link/#apollo-client).

If you open up `src/environment.js` in the the demo project, you'll see that it already contains a lot of
the boilerplate necessary to define an environment. There is, however, a core piece missing - the actual logic
to resolve the query. Let's add that now:

```javascript
import { graphql } from 'graphql'
import schema from './schema'

function fetchQuery(operation, variables) {
    return graphql(schema, operation.text, null, null, variables)
}

// ... everything else...
```

As you can see, resolving our queries does not involve a single network request as it would in the centralized
case. Instead, we just use the resolvers that we defined earlier to handle whatever queries we want. The
runtime is responsible for looking up the corresponding pieces of state in our contracts to fulfill the query.

With those two files in place, we should now be able to run our client and see a list of the auctions in
our platform. Start the development server with:

```bash
npm run relay && npm run dev
```

and navigate to http://localhost:8000. If everything goes right, you should now see a list of items for
every auction in our platform!

The rest of the stuff in the repo is unrelated to this post so we'll stop here without going over the
rest of the implementation details. If you are interested in seeing the actual query being fired here,
it's in [src/index.js](https://github.com/AlecAivazis/ethereum-graphql-demo/blob/master/src/index.js#L9-L15).

# Why is this Better?

By now you might be asking yourself if going through all this effort was worth it. If you have experience
working with `web3` then you know that the imperative API can become extremely duplicative without some
kind of domain specific abstraction layer. Take for example the code necessary to grab a list of every
auction in our platform (copied from above):

```javascript
// create a reference to the hub contract we created earlier
const hub = new web3.eth.Contract(HubABI, 'hub address from earlier')

// build the list of auctions
const auctions = []
for (let i = 0; i < (await hub.methods.auctionCount().call()); i++) {
    auctions.push(new web3.eth.Contract(AuctionABI, await hub.methods.auctions(i).call()))
}

return auctions
```

Since you cannot directly pull an array out of a contract, this same logic appears anywhere where the UI
needs to render a list of something. It's clear that the right move here is to have some kind of utility
that abstracts this logic away from your codebase wherever possible.

While it is possible to refactor this logic into an imperative utility that you can use in components
when necessary, by shifting this logic to a separate data layer, our components can stay declarative
functions of our "remote" data.

On top of the benefits of centralizing the logic to a single place, you also get all of the awesome
tooling that the graphql community has produced. This includes an
[interactive playground](https://github.com/prisma/graphql-playground) to explore
the state of your contracts as well as
[static insurance](https://github.com/apollographql/eslint-plugin-graphql) that your queries are valid.

# Conclusion and Next Steps

In this post, I showed you how to build a client-side GraphQL schema that resolves against smart contracts
running on an ethereum network. We then wired the schema to our user interface so we could easily query
the state of our contracts. This provided a nice abstraction for our UI to query our contracts without
worrying about how to retrieve the requested data.

To keep things focused, we only went over how to resolve a single query against the blockchain. However, there
is a lot of things that can be added on top to make the developer experience and your application
[plus ultra](https://www.quora.com/What-does-plus-ultra-mean-in-the-My-Hero-Academia-anime). Some of
those include:

-   Integrating a client-side [playground](https://github.com/prisma/graphql-playground) so you can
    easily explore your contracts
-   Tying [contract events](https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#events) into
    [GraphQL subscriptions](https://graphql.org/blog/subscriptions-in-graphql-and-relay/) for real
    time user interfaces.

=-=

That's it for now! Thanks for reading!

If you think this is a terrible idea, if you liked it, if you took a stab at the next steps, or you did
something else concerning this post, I want to know! Please reach out on twitter with your thoughts.

As always, if this is where we part ways, I hope you have a nice rest of your day.
