---
title: Building an Ethereum Dapp With GraphQL
subtitle: How to use GraphQL to isolate your UI from your contracts
path: '/blog/ethereum-graphql'
date: '2019-03-01'
---

Even the simplest decentralized applications involve information that is spread
across many different sources. Querying this information for a user interface
can become unwieldy as we have to hop across our collection of contracts to gather
the particular data that we need. Unless we are very careful, our components can easily become
intimately tied with the architecture details of our application. In this blog post,
I will show you how to use GraphQL as a powerful abstraction over your contracts that
ultimately simplifies the construction and maintainence of your dapp's user interface.

_This post is not meant to be an introduction to ethereum or graphql.
That being said, I will try to explain enough that you shouldn't need too much
familiarity with either to follow along. For a good introduction to the basics of
decentralized applications, I recommend
[this article](https://medium.com/@mvmurthy/ethereum-for-web-developers-890be23d1d0c).
For an introduction to GraphQL I recommend [starting here](https://graphql.org/learn/)._

=-=

In this post we will build an auction platform like [eBay](https://ebay.com) where users can
post items for sale that can be bid on by other users. For now, we won't take this example too
far and only show how one would fire a single query since the rest would be more of the same.
If you would like to see a more fleshed out example in the form of a multi-post series, please
let me know on twitter or [this project's repo](https://github.com/AlecAivazis/homepage).

The code for this post lives [on github](https://github.com/AlecAivazis/ethereum-graphql-demo).
The platform is made up of two different contracts. One is called `AuctionHub` which maintains
a list of addresses that point to instances of another contract called `Auction`. That second
contract only has a single public field: the name of the item for sale.

# Deploying The Contracts

Let's deploy some contracts to a test evironment so we have something to query. Clone the demo
project and install the project dependencies. A small warning: this might take a bit.

```bash
git clone git@github.com:AlecAivazis/ethereum-graphql-demo.git \
    && cd ethereum-graphql-demo \
    && npm i
```

Once it's done, start a local ethereum node we can test against:

```bash
npm run testnet
```

Notice the list of accounts under `Available Accounts`. We'll need one of them later. In
another terminal, compile the contracts:

```bash
npm run build:contracts
```

You should now have two files for each contract. The `*.bin` files are the compiled version
of each contract and the `*.abi` are a json files that describe the contents of the contract
(attributes, methods, etc.).

The demo project comes with a script that will bootstrap a few constracts and print the
address of the hub. You can run it with:

```bash
npm run init
```

With our contracts deployed, we are now ready to start querying them with GraphQL.

# Ethereum and GraphQL

If you have heard of GraphQL before, it's very likely that it was as a specification for a
server's API. In the decentralized world, there is no central server like there
is in traditional architectures. That does not mean, however, that we cannot take advantage of
all of the amazing tooling that the GraphQL community has produced.

By defining a schema that exists only in our client, we can use GraphQL as an abstraction layer over
our collection of contracts. This allows us to query the current state of our platform as if it was
a traditional server and resolve queries against the blockchain.

If you have some experience with GraphQL already, it might seem weird importing libraries like `graphql` and
`graphql-tools` into your client code. If you are worried about bundle size, keep in mind that it is likely
that you were already including most of the weight already as third-party imports from a few libraries that
are popular in the community.

# Building Our Client

For our little demo, we're going to be using [relay](https://facebook.github.io/relay/) to build our interface.
Don't worry if you haven't used it before, the repo already contains some components that we can just use
without worrying too much about how it works. Just know that if you change the queries that your components
are firing, or the graphql schema, you have to re-run the compiler with `npm run relay` for the changes to take effect.

## Defining the Schema

The first step to building our client-side graphql layer is the same as in the traditional world: define
the schema to represent our domain. This schema encodes the internal API between our UI
and contracts. This schema and its resolvers can even act as the handoff between the teams responsible
for blockchain and UI development (if that separation makes sense for you).

Let's start by adding a file named `schema.js` under the `src/` directory with this content:

```javascript
import { makeExecutableSchema } from 'graphql-tools'

const schema = `
    type Auction {
        itemName: String!
    }

    type Query {
        allAuctions: [Auction!]!
    }
`

export default makeExecutableSchema({
    typeDefs: schema,
})
```

If you have experience with the `graphql-tools` package then this should look familiar. What we've done
here is define a GraphQL schema that let's us query for all of the auctions in our system. You'll notice that
there is no mention of `AuctionHub` anywhere. That detail of the contract topology does not need to leak
into the UI's model of the contract state. Already we're seeing some benefits to this setup! Our UI
team doesn't have to understand how to find each auction. As we'll see in the bit, they just have
to be able to fire a query like `{ allAuctions { itemName } }`.

At the moment, keeping this in sync with the public attributes of our contract is a manual task.
It is possible to automate this for a smoother developer experience if you or your company finds
themselves doing this a lot.

## Specifying Resolvers

On it's own, a schema is not enough to resolve queries. We also need to tell the runtime
how to resolve the requested fields. This is done by defining an object whose keys are the type name and
whose values are another object with resolvers for the fields:

```javascript
import { makeExecutableSchema } from 'graphql-tools'
import { HubABI, AuctionABI } from '../contracts'

const schema = ...

const resolvers = {
    Auction: {
        // auction is an instance of the Auction contract wrapper
        itemName: auction => auction.itemName.call(),
    },
    Query: {
        allAuctions: () => {
            // create a reference to the hub contract we created earlier
            const hub = new web3.eth.Contract(HubABI, 'address from earlier')

            // we have to return an auction contract for each address
            // saved in the hub contract
            return (await hub.auctions.call()).map(
                addr => new web3.eth.Contract(AuctionABI, addr)
            )
        }
    },
}

export default makeExecutableSchema({
    typeDefs: schema,
    resolvers,
})
```

As you can see, we've told the runtime that resolving the `itemName` field on the
`Auction` contract requires invoking `itemName.call` on the auction contract. This returns a promise
with the the value of a
["constant" method](https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#methods-mymethod-call) which
will give us the string we want.
Similarly, we have resolved the list of all available auctions by looking at the auction hub
we created earlier and returning an instance of the auction constract for each address that the hub
has stored.

It's worth highlighting again that by doing this, we have completely abstracted away the existence of
the hub from the user interface. If we do in fact have separate teams working on the UI and
the blockchain infrastructure, this schema acts as a convinient touch point between the two teams.
If the blockchain team needs to rely on some centralized source as well, this schema can be easily
[stitched](https://www.apollographql.com/docs/graphql-tools/schema-stitching.html) with schemas from
remote APIs for powerful hybrid applications without complicating the user interface with those details.

## Querying Our Schema

With our schema in place, we are now ready to start wiring up the user interface and our contracts.
In relay, the central specification for how a query is resolved lives in an object known as the
[Environment](https://facebook.github.io/relay/docs/en/relay-environment.html). This is analogous
to a mixture of Apollo's `Link` and `Client` as described
[here](https://www.apollographql.com/docs/link/#apollo-client).

If you open up `src/environment.js` in the the demo project, you'll see that it already contains a lot of
the boilerplate necessary to define an environment. There is, however, a core piece missing - the actual logic
to resolve the query. Let's add that now:

```javascript
import { graphql } from 'graphql'
import schema from './schema'

function fetchQuery(operation, variables) {
    return graphql(schema, operation.text, null, null, variables)
}

// ... everything else...
```

As you can see, resolving our queries does not involve a single network request as it would in the centralized
case. Instead, we just use the resolvers that we defined earlier to handle whatever queries we want. The
runtime is responsible for looking up the corresponding pieces of state in our contracts to fulfill the query.

With those two files in place, we should now be able to run our client and see a list of the auctions in
our platform. Start the development server with:

```bash
npm run relay && npm run dev
```

and navigate to http://localhost:8000. If everything goes right, you should now see a list of items for
every auction in our platform!

# Conclusion and Next Steps

In this post, I showed you how to build a client-side GraphQL schema that resolves against smart contracts
running on an ethereum network. We then wired the schema to our user interface so we could easily query
the state of our contracts. This provided a nice abstraction for our UI to query our contracts without
worrying about how to retrieve the requested data.

To keep things focused, we only went over how to resolve a query against the blockchain. However, there
is a lot of things that can be added on top to make the developer experience
[plus ultra](https://www.quora.com/What-does-plus-ultra-mean-in-the-My-Hero-Academia-anime). Some of
those include:

-   Integrating a client-side [playground](https://github.com/prisma/graphql-playground) so you can
    easily explore your contracts
-   Tying [contract events](https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#events) into
    [GraphQL subscriptions](https://graphql.org/blog/subscriptions-in-graphql-and-relay/) for real
    time user interfaces.

=-=

That's it for now! Thanks for reading!

As always, if this is where we part ways, I hope you have a nice rest of your day.
