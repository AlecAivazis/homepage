---
title: Building an Ethereum Dapp With GraphQL
subtitle: How to use GraphQL to isolate your UI from your contracts
path: '/blog/ethereum-graphql'
date: '2019-03-01'
---

Even the simplest decentralized applications involve information that is spread
across many different places. Querying this information for a user interface
can become unwieldy as we have to hop across our collection of contracts to gather
the particular data that we need. Unless we are very careful, our components can easily become
intimately tied with the architecture details of our application. In this blog post,
I will show you how to use GraphQL as a powerful abstraction over your contracts that
ultimately simplifies the construction and maintainence of your dapp's user interface.

_This post is not meant to be someone's first introduction to ethereum or graphql.
That being said, I will try to explain enough that you shouldn't need too much
familiarity with either to follow along. For a good introduction to the basics of
decentralized applications, I recommend
[this article](https://medium.com/@mvmurthy/ethereum-for-web-developers-890be23d1d0c).
For an introduction to GraphQL I recommend [starting here](https://graphql.org/learn/)._

=-=

In this post we will build an auction platform like [eBay](https://ebay.com) where users can
post items for sale that can be bid on by other users. After a designated time, the owner
of the auction can close the auction and transfer the ownership of the item to the winner.

In this tutorial our contracts will be written in Solidity. As the actual content of the
contracts is not important for this post, I'll post it below with comments to explain what's
going on but won't go into much more detail. For more information on building smart contracts
with Solidity you can check out [this series](https://medium.com/coinmonks/solidity-getting-started/home).

```solidity
pragma solidity ^0.4.22;

// the primary contract for our auctions
contract Auction {

}

// the central contract that knows the address of each auction
contract AuctionHub {
    // the list of auctions
    address[] public auctions
}
```

tl;dr - There is a contract called `AuctionHub` that has a list of addresses that point to
instances of another contract called `Auction`. That second contract has what you'd expect:
a method for users to submit an offer and a method for the owner to close the auction
and give the winner their prize.

# Deploying The Contracts

Let's deploy some contracts to a test evironment so we have something to query. Go to an empty
directory and install a few dependencies:

```bash
& npm install ganache-cli web3@1.0.0-beta.37
```

and then start a local ethereum network we can test against:

```bash
& npx ganache-cli
```

# Querying Our Contracts with GraphQL

With our contracts deployed, we are now ready to start querying them with GraphQL.

## A GraphQL Schema For Our Contracts

## Resolving Queries

## Debugging With GraphiQL
