---
title: Building an Ethereum Dapp With GraphQL
subtitle: How to use GraphQL to isolate your UI from your contracts
path: '/blog/ethereum-graphql'
date: '2019-03-01'
---

Even the simplest decentralized applications involve information that is spread
across many different places. Querying this information for a user interface
can become unwieldy as we have to hop across our collection of contracts to gather
the particular data that we need. Unless we are very careful, our components can easily become
intimately tied with the architecture details of our application. In this blog post,
I will show you how to use GraphQL as a powerful abstraction over your contracts that
ultimately simplifies the construction and maintainence of your dapp's user interface.

_This post is not meant to be someone's first introduction to ethereum or graphql.
That being said, I will try to explain enough that you shouldn't need too much
familiarity with either to follow along. For a good introduction to the basics of
decentralized applications, I recommend
[this article](https://medium.com/@mvmurthy/ethereum-for-web-developers-890be23d1d0c).
For an introduction to GraphQL I recommend [starting here](https://graphql.org/learn/)._

=-=

In this post we will build an auction platform like [eBay](https://ebay.com) where users can
post items for sale that can be bid on by other users. After a designated time, the owner
of the auction can close the auction and transfer the ownership of the item to the winner.

The code for this post live [on github](https://github.com/AlecAivazis/graphql-ethereum-demo).
The platform is made up of two different contracts. One is called `AuctionHub` and has a list of
addresses that point to instances of another contract called `Auction`. That second
contract has what you'd expect: a method for users to submit an offer and a method for
the owner to close the auction and give the winner their prize.

# Deploying The Contracts

Let's deploy some contracts to a test evironment so we have something to query. Clone the demo
project and install the project dependencies. This might take a bit:

```bash
& git clone git@github.com:AlecAivazis/ethereum-graphql-demo.git \
    && cd ethereum-graphql-demo \
    && npm i
```

and then start a local ethereum node we can test against:

```bash
& npm run testnet
```

Notice the list of accounts under `Available Accounts`. We'll need one of them later. In
another terminal, compile the contracts:

```bash
& npm run build:contracts
```

You should now have two files for each contract. The `*.bin` files are the compiled version
of each contract and the `*.abi` are a json files that describe the contents of the contract
(attributes, methods, etc.).

The demo project comes with a script that will bootstrap a few constracts and print the
address of the hub. You can run it with:

```bash
& npm run init
```

With our contracts deployed, we are now ready to start querying them with GraphQL.

# Ethereum and GraphQL

If you have heard of graphql before, it's very liekly that it was in the context of as
a specification for a server's API. In the decentralized world, there is no central server like there
is in traditional architectures. That does not mean, however, that we cannot take advantage of
all of the amazing tooling that the GraphQL community has produced.

By defining an object in our client that we can use to resolve our queries, we can use
GraphQL as an abstraction layer over our collection of contracts. This allows us to query the current
state of our platform as if it was a traditional server and resolve queries against the blockchain.

While it might seem weird importing libraries like `graphql` and `graphql-tools` into your client code,
it is likely that you were already include most of the weight already as third-party imports from various
libraries popular in the community.

# Our Project

For our little demo, we're going to be using [relay](https://facebook.github.io/relay/) to build our interface.
Don't worry if you haven't used it before, the repo already contains some components that we can just use
without worrying too much about how it works. Just know that if you change the queries that your components
are firing, or the graphql schema, you have to re-run the compiler with `npm run relay`.

If you try to run the project with `npm run dev`, you'll quickly notice that a few things are missing.

# A GraphQL Schema For Our Contracts

The first step to building our client-side graphql layer is the same as in the traditional world: define
the schema which represents our domain. At the moment this is a manual task however it is possible to
automate this for a smoother developer experience. For our simple situation we need to define

# Resolving Queries

## Debugging With GraphiQL
