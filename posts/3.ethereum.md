---
title: Building an Ethereum Dapp With GraphQL
subtitle: How to use GraphQL to isolate your UI from your contracts
path: '/blog/ethereum-graphql'
date: '2019-03-01'
---

Even the simplest decentralized applications involve information that is spread
across many different places. Querying this information for a user interface
can become unwieldy as we have to hop across our collection of contracts to gather
the particular data that we need. Unless we are very careful, our components can easily become
intimately tied with the architecture details of our application. In this blog post,
I will show you how to use GraphQL as a powerful abstraction over your contracts that
ultimately simplifies the construction and maintainence of your dapp's user interface.

_This post is not meant to be someone's first introduction to ethereum or graphql.
That being said, I will try to explain enough that you shouldn't need too much
familiarity with either to follow along. For a good introduction to the basics of
decentralized applications, I recommend
[this article](https://medium.com/@mvmurthy/ethereum-for-web-developers-890be23d1d0c).
For an introduction to GraphQL I recommend [starting here](https://graphql.org/learn/)._

=-=

In this post we will build an auction platform like [eBay](https://ebay.com) where users can
post items for sale that can be bid on by other users. After a designated time, the owner
of the auction can close the auction and transfer the ownership of the item to the winner.

In this tutorial our contracts will be written in Solidity. As the actual content of the
contracts is not important for this post, I'll post it below with comments to explain what's
going on but won't go into much more detail. For more information on building smart contracts
with Solidity you can check out [this series](https://medium.com/coinmonks/solidity-getting-started/home).

```solidity
pragma solidity ^0.4.22;

// the primary contract for our auctions
contract Auction {
    string public itemName
}

// the central contract that knows the address of each auction
contract AuctionHub {
    // the list of auctions
    address[] public auctions
}
```

tl;dr - There is a contract called `AuctionHub` that has a list of addresses that point to
instances of another contract called `Auction`. That second contract has what you'd expect:
a method for users to submit an offer and a method for the owner to close the auction
and give the winner their prize.

# Deploying The Contracts

Let's deploy some contracts to a test evironment so we have something to query. Go to an empty
directory and install a few dependencies. This might take a bit:

```bash
& npm install ganache-cli web3 solc
```

and then start a local ethereum node we can test against:

```bash
& npx ganache-cli
```

Notice the list of accounts under `Available Accounts`. We'll need one of them lateer. In
another terminal, copy the content of the codeblock above into a file called `contracts.sol`.
The next step is to compile the contracts:

```bash
& npx solcjs --bin --abi contracts.sol
```

You should now have two files for each contract. The `*.bin` files are the compiled version
of each contract and the `*.abi` are a json files that describe the contents of the contract
(attributes, methods, etc.).

Instead of worrying about building out a UI to create the contracts as well as view them,
let's just create them from the node repl. If you recall, we have two
kinds of contracts in our platform. Each auction is represented by the `Auction` contract
and is registered with a single instance of the `AuctionHub` contract. This single `AuctionHub`
acts as the source of truth for the list of auctions in our platform.

Start the node repl and connect to the testnet that you started earlier:

```bash
$ node
> Web3 = require('web3')
> web3 = new Web3("http://localhost:8545")
```

We now have to deploy a few contracts to boostrap our system. First, load up the files that
we created earlier with `solc`:

```bash
> hubBytecode = fs.readFileSync('contracts_sol_AuctionHub.bin').toString()
> hubABI = JSON.parse(fs.readFileSync('contracts_sol_AuctionHub.abi').toString())
> auctionBytecode = fs.readFileSync('contracts_sol_Auction.bin').toString()
> auctionABI = JSON.parse(fs.readFileSync('contracts_sol_Auction.abi').toString())
```

And create some wrappers over our contracts:

```bash
> hubContract = new web3.eth.Contract(hubABI)
> auctionContract = new web3.eth.Contract(auctionABI)
```

The only thing left is to create a few auctions and then a hub with those addresses in place:

```javascript
> Promise.all([... new Array(3)].map(async (_, i) => {
    // create an auction
    const auction = await auctionContract.deploy({
        data: auctionBytecode,
        arguments: [`Auction ${i}`],
    }).send({
        from: 'address from above',
        gas: 1400000,
        gasPrice: web3.utils.toWei('0.00002', 'ether')
    })

    // we want a list of each address that we created
    return auction.address

})).then(async addresses => {
    // create a hub with the list of addresses
    const hub = await hubContract.deploy({
        data: auctionBytecode,
        arguments: [addresses],
    }).send({
        from: 'address from above',
        gas: 1400000,
        gasPrice: web3.utils.toWei('0.00002', 'ether')
    })

    console.log(`Hub deployed at ${hub.address}`)
})
```

After all of this, you should have three auctions in your test net each named `"Auction {1,2,3}"`
and a hub located at the designated address with the address of each of the auctions.

# Querying Our Contracts with GraphQL

With our contracts deployed, we are now ready to start querying them with GraphQL. If you have heard of
graphql before, it's most almost garunteed that it was in the context of a tool for building APIs for
servers. In the decentralized world,

## A GraphQL Schema For Our Contracts

## Resolving Queries

## Debugging With GraphiQL
